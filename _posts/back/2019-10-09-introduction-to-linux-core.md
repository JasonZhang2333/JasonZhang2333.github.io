---
layout: post
title: "《深入Linux内核架构》内核"
date: 2019-10-09
author: "Zzc"
header-style: text
mathjax: true
catalog: true
tags:
  - 编程
  - 操作系统
  - Linux
  - 内核
  - 笔记
---

> 本文基于《深入理解Linux内核架构》第一章，`Linux`为`2.6.24`版本

![img](/img/in-post/post-introduction-to-linux-core/201910091506.png)
*Linux内核概述*

### 进程

每个进程在CPU的虚拟内存中分配地址空间，进程彼此独立，通信必须通过特定的内核机制。

系统中同时运行的进程数不超过CPU数，内核会进行进程切换和调度：
1. 在撤销进程的CPU资源前保存进程所有状态，并将进程置于空闲状态，重新激活进程时所保存的状态原样恢复
2. 内核确定如何在进程间分配CPU时间，重要的进程得到的多一点

`Linux`对进程采用层次结构，每个进程依赖于一个父进程，内核启动`init`程序作为第一个进程负责系统初始化操作，因此`init`是进程树的根。

`UNIX`有两种进程创建机制：
1. `fork`创建当前进程的一个副本，父子进程只有PID不同，`Linux`采用写时复制(copy on write)技术，内存复制操作延迟到父进程或子进程向内存页面写入数据之前
2. `exec`将新进程加载到当前进程的内存中执行，旧程序的内容将被替换为新的数据

一个进程可以由若干线程组成，线程共享同样的数据和资源，执行不同的代码部分，`Linux`用`clone`方法创建线程，工作方式类似`fork`，但会确认哪些资源与父进程共享，哪些资源为线程独自创建。

不同的命名空间可以使不同的进程看到不同的系统视图，每个命名空间看起来就像是运行`Linux`的一台计算机，这有助于更有效地使用资源。

### 内存

###### 地址空间与特权级别

![img](/img/in-post/post-introduction-to-linux-core/201910091757.png)
*虚拟地址空间的划分*


系统中每个进程的地址空间中只有自身存在，这一地址空间成为虚拟地址空间，其最大长度取决于CPU的字长，`Linux`将虚拟地址空间划分为内核空间和用户空间，如图所示，系统中每个用户进程都有自身的虚拟地址范围，从0到`TASK_SIZE`，从`TASK_SIZE`到$2^{64}$留给内核专用，`TASK_SIZE`的划分取决于具体的计算机体系结构。

![img](/img/in-post/post-introduction-to-linux-core/201910091827.png)
*系统调用和中断的状态切换*

尽管`Intel`处理器区分了四种特权级别，`Linux`只使用内核态和用户态两种状态，状态的区别在于可访问的内存区域：
- 用户态禁止访问内核空间，防止进程修改彼此数据造成干扰
- 从用户态到内核态切换需要通过系统调用，系统调用后内核会检查进程是否允许执行相应操作，然后代表进程执行，之后返回到用户态
- 异步硬件中断可以激活内核态，然后内核态在中断上下文中运行，中断可能在任一用户进程活动时发生，所以中断上下文中内核禁止访问虚拟地址空间的用户空间
- 系统中还有内核线程运行，内核线程不与任何用户进程关联，禁止访问用户空间，用户线程可以用于各种用途：内存和块设备的数据同步、帮助调度器在CPU上分配进程等等；在`ps`命令输出中内核线程的名称都位于方括号内，方括号内斜线后的数字代表线程指定的CPU

###### 虚拟和物理地址空间

**虚拟地址空间和物理地址空间的映射**

![img](/img/in-post/post-introduction-to-linux-core/201910091902.png)
*虚拟和物理地址*

`Linux`采用分页的方法实现虚拟地址空间到物理内存的映射，将物理地址划分为等大小的页帧，虚拟地址空间也划分为同样大小的页，通过页表与物理内存的页帧映射，如图所示；不同进程的不同页可以映射到同一物理地址页帧，有的虚拟地址空间的页可能没有映射的页帧，需要时再向物理地址载入对应的页帧。

将虚拟地址空间映射到物理地址空间的数据结构称为**页表**，对虚拟地址空间的每一页分配一个数组项的方法最容易，但这样保存页表需要占用太多物理地址空间，而且大多数虚拟地址空间都没有使用，因此采用功能相同但占用内存更少的**多级分页**模型。

![img](/img/in-post/post-introduction-to-linux-core/201910091943.png)
*多级分页模型*

`Linux`采用四级页表，这里为了简化展示了三级页表，三级页表将虚拟地址划分为四个部分：
- 全局页目录(Page Global Directory, `PGD`)，每个进程有且仅有一个`PGD`数组，虚拟地址对应的部分索引到`PGD`的数据项，数据项指向下一级`PMD`数组的起始地址
- 中间页目录(Page Middle Directory, `PMD`)，在通过`PGD`中的数组项找到对应的`PMD`之后，使用虚拟地址对应的部分索引到`PMD`的数据项，`PMD`中的数据项也是指针，指向下一级`PTE`数组的起始地址
- 页表数组(Page Table Entry, `PTE`)，`PTE`用作页表的索引，虚拟内存页和页帧之间的映射完成，`PTE`中的数据项指向具体的页帧
- 虚拟地址最后一部分称为偏移量，指定页内部的一个字节位置，最后，每个虚拟地址都指向物理地址中唯一定义的某个字节

多级页表存在着相应的优缺点：
- 多级页表对虚拟地址空间不需要的部分不创建`PMD`或`PTE`，节省了大量内存
- 多级页表每次访问内存必须逐级访问多个数组，CPU试图通过两种方法加速
1. CPU中有专门的部分叫内存管理单元(Memory Management Unit, `MMU`)，用于优化内存访问
2. 地址转换中最频繁的那些地址会保存到名叫地址转换后备缓冲器(Translation Lookaside Buffer, `TLB`)的CPU高速缓存中，无需访问页表即可获得地址，大大加速了地址转换，但每当页表内容变化时必须使`TLB`高速缓存无效

内存映射是一种重要的抽象手段，可以将文件、外设输出输出等任意来源的数据映射到虚拟地址空间，这样就可以像访问普通内存一样访问其他数据来源，使用相同的函数处理不同的目标对象。

**物理内存的分配**

内核分配内存时，必须记录页帧的分配或空闲状态，以避免两进程使用同样的内存区域，为保证效率，内核只分配完整的页帧。

内核很多时候要求分配连续页，为了防止内存碎片的产生，内核采用伙伴系统的技术：系统中的空闲内存块总是两两分组，每组内的内存块称为伙伴，如果两个伙伴都是空闲的，内核会将其合并，作为下一层次的组内的内存块。

![img](/img/in-post/post-introduction-to-linux-core/201910092023.png)
*伙伴系统*

如图所示，一开始有一块16个连续页帧构成的内存块，内核需要分配8个页帧的空间，就将内存块拆分成两个伙伴，分配其中的一个；然后内核需要分配2个页帧的空间，就将剩余8个页帧拆分成两个伙伴，再将其中一个内存块再次拆分，就得到了2个页帧大小的内存块进行分配，在应用程序释放内存时，内核可以检查地址，对空闲的伙伴进行合并，刚好是内存块分裂的逆过程。

伙伴系统可以缓解内存碎片，但无法完全消除。

![img](/img/in-post/post-introduction-to-linux-core/201910092044.png)
*slab缓存*

由于内核经常需要比页帧小得多的内存块，又无法使用标准库函数进行分配，所以内核在伙伴系统的基础上自行定义了额外的内存管理层用于划分更小的内存块，这一内存管理层还为频繁使用的小对象实现了缓存——`slab`缓存，`slab`缓存使用两种方法分配内存：
1. 对频繁使用的小对象，内核定义了只包含所需类型对象实例的缓存，每次需要就可以快速分配
2. 对通常情况小内存块的分配，内核对不同大小的对象定义了一组`slab`缓存，可以用同样的函数`kmalloc`和`kfree`访问这些缓存

**页面交换**：内核在需要更多内存时，将不经常使用的页写入硬盘，换出的页通过特别的页表项标识，当进程试图访问此类页帧时，CPU启动一个缺页异常，此时内核将硬盘上的数据切换回内存，用户进程就可以继续执行了，这一过程对进程时完全不可见的。

**页面回收**：内核在需要更多内存时，会将用作页缓存的内容回写到底层的设备，然后释放页帧，内核的数据结构也包含了相关的所有信息，当再次需要该数据时，可以从硬盘找到相应的数据并加载。

### 其他

###### 系统调用

`Linux`按照`POSIX`标准定义了许多系统调用，传统的系统调用一般可分为：
- 进程管理：创建新进程、查询信息、调试
- 信号：发送信号、定时器及相关处理机制
- 文件：创建、打开、关闭、读写文件，查询信息和状态
- 目录和文件系统：创建、删除、重命名目录，查询信息，链接，变更目录
- 保护机制：读取、变更`UID`/`GID`，处理命名空间
- 定时器函数：定时器函数和统计信息

所有这些函数都对内核提出了要求，不能以普通的用户库形式来实现，在发出系统调用时，处理器必须从用户态切换到内核态。

###### 设备

> `UNIX`箴言：万物皆文件(everything is a file)

`Linux`对设备的处理完全类似于常规的文件，都可以通过利用`/dev`目录下的设备文件来完成，设备驱动程序用于支持应用程序经由设备文件与设备通信。

外设可分为以下两类：
- 字符设备：提供连续的数据流，应用程序按照字节/字符顺序读写数据，如调制解调器
- 块设备：应用程序可以随机访问设备数据，只能以块的倍数来读写数据，如硬盘

应用程序从低速的块设备上读取数据时会暂时存储在内存中，下一次访问时，可以直接从速度较快的内存中读取，由于内核是通过基于页的内存映射来访问块设备的，因此缓存也按照页来组织，故称为页缓存(page cache)。

网卡在设备中属于特殊情况，不能用设备文件访问，因为网络通信过程中，数据需要经过各协议层的打包和拆包，为了支持通过文件接口处理网络连接，`Linux`使用了套接字抽象。

###### 文件系统

![img](/img/in-post/post-introduction-to-linux-core/201910100006.png)
*虚拟文件系统、文件系统与块设备*

`Linux`系统存储采用了层次式文件系统，使用目录结构组织存储的数据，并将所有者、访问权限等元信息与实际数据关联起来。

`Linux`支持许多文件系统，像标准的`Ext2`/`Ext3`/`Ext4`、`XFS`、`VFAT`等，`Ext2`为每个文件都构造了一个单独的管理结构`inode`，`inode`包含了所有的元信息和指向相关数据块的指针，目录可以表示为普通文件，其包含了指向其下所有文件的`inode`的指针，从而建立起层次结构。

为了将文件系统的具体实现和应用层隔离开来，内阁提供了一个额外的软件层，称为虚拟文件系统(Virtual File System, `VFS`)，从而使文件系统的实现对内核和应用程序不可见。
