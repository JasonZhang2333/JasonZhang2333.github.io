---
layout: post
title: "分治法、动态规划与贪心算法"
date: 2018-10-16
author: "Zzc"
header-style: text
mathjax: true
catalog: true
tags:
  - 分治法
  - 动态规划
  - 贪心算法
  - 算法
  - 编程
---

### 算法简介

###### 分治法

分治法求解问题分为三个步骤：
1. 原问题分解为同质子问题
2. 求解子问题
3. 合并子问题的解，得到原问题的解

分治法求解的问题一般具有分形的特点，即原问题可以分解成同类型规模更小的子问题，但是规模降低到一定程度的子问题可以通过简单的方法直接求解，求出的解又可以合并成原问题的解，分治法通过递归的结构实现这一流程。

###### 动态规划

![img](/img/in-post/post-algorithm-comparison/timg.jpg)
*有向无环图*

动态规划求解问题分为四个步骤：
1. 将原问题转化为有向无环图状态转移问题
2. 将原问题沿路径分解为子问题
3. 求解子问题
4. 根据子问题的解推导出原问题的解

动态规划可以求解的问题都可以简化成加权有向无环图，变成一个路径约束问题，既然已知原问题难以求解，又只有有限的路径可以进一步到达原问题，就可以将原问题分解为各个路径中上一步子问题，如果求解出子问题，比较各个子问题的最优解就可以进一步求解出原问题；然后每个子问题也只有有限的路径到达，又可以将子问题进一步分解，从而不断将问题化简，最终化简到可以直接求解的最简化问题；最后以小问题的解支持大问题求解的方法，依次解决所有的子问题，最终得到原问题的解。

###### 贪心算法

贪心算法实际上是特殊的动态规划问题，如果原问题是一个凸优化问题，那么每步采取局部最优策略就可以不断逼近整体最优，简单地求解出原问题。

### 区别与联系

分治法、动态规划与贪心算法实际上是一种层层递进的关系，三种算法最大的共同点就是原问题可以分解成子问题，而原问题的最优解包含子问题的最优解，在此基础上，动态规划是分治法的特殊情况，贪心算法是动态规划的特殊情况。

分治法适用于可以分解成同质子问题的问题，子问题之间求解相互独立，因而原问题可以类似于多叉树一般不断分割，最后通过递归方式求解；然而很多实际问题的求解中，子问题不是相互独立的，是有重叠的，这时候通过分治法求解，就会存在子问题的重复求解，产生计算的浪费，此类问题采用动态规划算法，实际上是将分治法多叉树中同样的子问题合并，多叉树就变成了动态规划中的有向无环图，此时就不能采用分治法的递归算法，而要通过一个表来记录子问题的解。

动态规划算法求解的是一个优化问题，但是不一定是一个凸优化问题，可能存在多个局部最优并不是全局最优，而问题如果是一个凸优化问题，局部最优一定是全局最优，此类问题就不必通过动态规划这么复杂的算法求解，直接通过贪心算法求出每步的局部最优解，自顶而下地求解问题即可。

### 算法开销

###### 分治法

![img](/img/in-post/post-algorithm-comparison/timg2.jpeg)
*归并排序*

以归并排序为例分析分治法的算法开销，归并排序将数组以二叉树的形式对半分割，直至分割至单个元素一个节点，然后通过两两比较的方式递归合并，如图所示，算法的主要开销用于合并部分，拆分部分的时间复杂度为$O(\log n)$，空间复杂度为$O(1)$，比合并部分小得多，因而主要分析合并部分即可。

归并排序的每层合并的总体规模都不变，因而只需要分配固定的内存空间即可，需要的内存空间大小随数组长度线性增长，因而内存开销为$O(n)$；时间开销上，每层两两合并时，两个子问题解合并需要$O(k_1+k_2)$，这样单层所有子问题的解合并需要$O(n)$，由于是二叉树形式，总共需要的合并层数是$O(\log n)$，所以算法总的时间复杂度为$O(n\log n)$。

分治法对于内存空间要求较少，时间的复杂度主要受到每层合并所需时间的影响，像归并排序，即便遭遇最差的排序初始顺序的影响，时间复杂度也不会大于$O(n^2)$，所以对于子问题的解合并程序较为简单的问题，分治法是一个很好的解决方案。

###### 动态规划

以背包问题为例来分析动态规划的算法开销，背包问题又可以分成两种类型，一种是物品可重复的背包问题，另一种是物品不可重复的。

假设背包载重为W，共有n件物品，分别重$w_1,w_2...,w_n$，价值$v_1,v_2...,v_n$，多物品问题下就可以通过$K(w)=\max \limits_{w_i\le w} \{K(w-w_i)+v_i\}$来转化问题递归求解，内存开销只有一个$W+1$长的数组，所以空间复杂度为$O(W)$，表格中每个值的计算的时间复杂度为$O(n)$，因而算法整体的时间复杂度为$O(Wn)$。

对于物品不可重复的情况，要在空间维度上加上物品范围的维度，迭代求解的方法变为$K(w,i)=\max \limits_{w_i\le w} \{K(w-w_i,i-1)+v_i,K(w,i-1)\}$，表格大小变为$W+1$行和$n+1$列，表格中每个值的计算的时间复杂度为$O(1)$，因而空间复杂度和时间复杂度都为$O(Wn)$。

动态规划问题实际上是以空间换时间，增加空间复杂度以保存计算过的子问题的解，来降低时间复杂度。算法的时间复杂度较为确定，可以基于子问题的数量和单个子问题的时间复杂度来计算，空间复杂度一般也和子问题的规模成正比。

###### 贪心算法

以硬币问题来分析贪心算法的算法开销，假设有$n$种硬币，币值从大到小排列，对于给定的钱数$N$，求出构成$N$所需最少的硬币数。解法是一次从大到小遍历所有币值硬币，每种币值硬币取使总币值小于$N$的最大数量，这样单个硬币的时间复杂度为$O(1)$，总的时间复杂度开销为$O(n)$，空间复杂度为$O(n)$，如果需要对币值进行排序，则可以采用归并排序，时间复杂度上升到$O(n\log n)$。

贪心算法的时间复杂度和空间复杂度一般都较低，对于特定的凸优化问题能够取得最好的效率，但是算法适用范围较小。
