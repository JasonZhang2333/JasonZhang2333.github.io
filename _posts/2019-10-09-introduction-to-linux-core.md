---
layout: post
title: "《深入Linux内核架构》内核简介"
date: 2019-10-09
author: "Zzc"
header-style: text
mathjax: true
catalog: true
tags:
  - 编程
  - 操作系统
  - Linux
  - 内核
  - 笔记
---

> 本文基于《深入理解Linux内核架构》第一章，`Linux`为`2.6.24`版本

![img](/img/in-post/post-introduction-to-linux-core/201910091506.png)
*Linux内核概述*

### 进程与线程

每个进程在CPU的虚拟内存中分配地址空间，进程彼此独立，通信必须通过特定的内核机制

系统中同时运行的进程数不超过CPU数，内核会进行进程切换和调度：
1. 在撤销进程的CPU资源前保存进程所有状态，并将进程置于空闲状态，重新激活进程时所保存的状态原样恢复
2. 内核确定如何在进程间分配CPU时间，重要的进程得到的多一点

`Linux`对进程采用层次结构，每个进程依赖于一个父进程，内核启东`init`程序作为第一个进程负责系统初始化操作，因此`init`是进程树的根

`UNIX`有两种进程创建机制：
1. `fork`创建当前进程的一个副本，父子进程只有PID不同，`Linux`采用写时复制(copy on write)技术，内存复制操作延迟到父进程或子进程向内存页面写入数据之前
2. `exec`将新进程加载到当前进程的内存中执行，旧程序的内容将被替换为新的数据

一个进程可以由若干线程组成，线程共享同样的数据和资源，执行不同的代码部分，`Linux`用`clone`方法创建线程，工作方式类似`fork`，但会确认哪些资源与父进程共享，哪些资源为线程独自创建

不同的命名空间可以使不同的进程看到不同的系统视图，每个命名空间看起来就像是运行`Linux`的一台计算机，这有助于更有效地使用资源

### 内存

![img](/img/in-post/post-introduction-to-linux-core/201910091757.png)
*虚拟地址空间的划分*


系统中每个进程的地址空间中只有自身存在，这一地址空间成为虚拟地址空间，其最大长度取决于CPU的字长，`Linux`将虚拟地址空间划分为内核空间和用户空间，如图所示，系统中每个用户进程都有自身的虚拟地址范围，从`0`到`TASK_SIZE`，从`TASK_SIZE`到`$2_64$`留给内核专用，`TASK_SIZE`的划分取决于具体的计算机体系结构

尽管`Intel`处理器区分了四种特权级别，`Linux`只使用内核态和用户态两种状态，状态的区别在于可访问的内存区域
- 用户态禁止访问内核空间
