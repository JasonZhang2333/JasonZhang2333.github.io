---
layout: post
title: "《深入Linux内核架构》内核简介"
date: 2019-10-09
author: "Zzc"
header-style: text
mathjax: true
catalog: true
tags:
  - 编程
  - 操作系统
  - Linux
  - 内核
  - 笔记
---

> 本文基于《深入理解Linux内核架构》第一章，`Linux`为`2.6.24`版本

![img](/img/in-post/post-introduction-to-linux-core/201910091506.png)
*Linux内核概述*

### 进程

每个进程在CPU的虚拟内存中分配地址空间，进程彼此独立，通信必须通过特定的内核机制

系统中同时运行的进程数不超过CPU数，内核会进行进程切换和调度：
1. 在撤销进程的CPU资源前保存进程所有状态，并将进程置于空闲状态，重新激活进程时所保存的状态原样恢复
2. 内核确定如何在进程间分配CPU时间，重要的进程得到的多一点

`Linux`对进程采用层次结构，每个进程依赖于一个父进程，内核启东`init`程序作为第一个进程负责系统初始化操作，因此`init`是进程树的根

`UNIX`有两种进程创建机制：
1. `fork`创建当前进程的一个副本，父子进程只有PID不同，`Linux`采用写时复制(copy on write)技术，内存复制操作延迟到父进程或子进程向内存页面写入数据之前
2. `exec`将新进程加载到当前进程的内存中执行，旧程序的内容将被替换为新的数据

一个进程可以由若干线程组成，线程共享同样的数据和资源，执行不同的代码部分，`Linux`用`clone`方法创建线程，工作方式类似`fork`，但会确认哪些资源与父进程共享，哪些资源为线程独自创建

不同的命名空间可以使不同的进程看到不同的系统视图，每个命名空间看起来就像是运行`Linux`的一台计算机，这有助于更有效地使用资源

### 内存

###### 地址空间与特权级别

![img](/img/in-post/post-introduction-to-linux-core/201910091757.png)
*虚拟地址空间的划分*


系统中每个进程的地址空间中只有自身存在，这一地址空间成为虚拟地址空间，其最大长度取决于CPU的字长，`Linux`将虚拟地址空间划分为内核空间和用户空间，如图所示，系统中每个用户进程都有自身的虚拟地址范围，从`0`到`TASK_SIZE`，从`TASK_SIZE`到`$2_64$`留给内核专用，`TASK_SIZE`的划分取决于具体的计算机体系结构

![img](/img/in-post/post-introduction-to-linux-core/201910091827.png)
*系统调用和中断的状态切换*

尽管`Intel`处理器区分了四种特权级别，`Linux`只使用内核态和用户态两种状态，状态的区别在于可访问的内存区域
- 用户态禁止访问内核空间，防止进程修改彼此数据造成干扰
- 从用户态到内核态切换需要通过系统调用，系统调用后内核会检查进程是否允许执行相应操作，然后代表进程执行，之后返回到用户态
- 异步硬件中断可以激活内核态，然后内核态在中断上下文中运行，中断可能在任一用户进程活动时发生，所以中断上下文中内核禁止访问虚拟地址空间的用户空间
- 系统中还有内核线程运行，内核线程不与任何用户进程关联，禁止访问用户空间，用户线程可以用于各种用途：内存和块设备的数据同步、帮助调度器在CPU上分配进程等等；在`ps`命令输出中内核线程的名称都位于方括号内，方括号内斜线后的数字代表线程指定的CPU

###### 虚拟和物理地址空间

![img](/img/in-post/post-introduction-to-linux-core/201910091902.png)
*虚拟和物理地址*

`Linux`采用分页的方法实现虚拟地址空间到物理内存的映射，将物理地址划分为等大小的页帧，虚拟地址空间也划分为同样大小的页，通过页表与物理内存的页帧映射，如图所示；不同进程的不同页可以映射到同一物理地址页帧，有的虚拟地址空间的页可能没有映射的页帧，需要时再向物理地址载入对应的页帧

将虚拟地址空间映射到物理地址空间的数据结构称为**页表**，对虚拟地址空间的每一页分配一个数组项的方法最容易，但这样保存页表需要占用太多物理地址空间，而且大多数虚拟地址空间都没有使用，因此采用功能相同但占用内存更少的**多级分页**模型

![img](/img/in-post/post-introduction-to-linux-core/201910091943.png)
*多级分页模型*

`Linux`采用四级页表，这里为了简化展示了三级页表，三级页表将虚拟地址划分为四个部分：
- 全局页目录(Page Global Directory, `PGD`)，每个进程有且仅有一个`PGD`数组，虚拟地址对应的部分索引到`PGD`的数据项，数据项指向下一级`PMD`数组的起始地址
- 中间页目录(Page Middle Directory, `PMD`)，在通过`PGD`中的数组项找到对应的`PMD`之后，使用虚拟地址对应的部分索引到`PMD`的数据项，`PMD`中的数据项也是指针，指向下一级`PTE`数组的起始地址
- 页表数组(Page Table Entry, `PTE`)，`PTE`用作页表的索引，虚拟内存页和页帧之间的映射完成，`PTE`中的数据项指向具体的页帧
- 虚拟地址最后一部分称为偏移量，指定页内部的一个字节位置，最后，每个虚拟地址都指向物理地址中唯一定义的某个字节

- 多级页表对虚拟地址空间不需要的部分不创建`PMD`或`PTE`，节省了大量内存
- 多级页表每次访问内存必须逐级访问多个数组，CPU试图通过两种方法加速
1. CPU中有专门的部分叫内存管理单元(Memory Management Unit, `MMU`)，用于优化内存访问
2. 地址转换中最频繁的那些地址会保存到名叫地址转换后备缓冲器(Translation Lookaside Buffer, `TLB`)的CPU高速缓存中，无需访问页表即可获得地址，大大加速了地址转换，但每当页表内容变化时必须使`TLB`高速缓存无效

