---
layout: post
title: "《深入Linux内核架构》进程"
date: 2019-10-23
author: "Zzc"
header-style: text
catalog: true
tags:
  - 编程
  - 操作系统
  - Linux
  - 进程管理
  - 笔记
---

> 本文基于《深入理解Linux内核架构》第二章，`Linux`为`2.6.24`版本。

内核需要处理进程相关的两个任务：
1. 为各个进程分配多长时间，何时切换到下一进程，这取决于调度器策略，与平台无关
2. 在进程切换后，必须保证切换到进程的执行环境与之前完全相同，这与处理器极度相关，需要汇编实现

### 优先级与生命周期

![img](/img/in-post/post-process-management/201910231734.png)

*通过时间片分配CPU时间*

进程按照时间片调度，分配的时间片份额和进程相对重要性相当，这种方案称为抢占式多任务处理(preemptive multitasking)，被抢占进程的所有寄存器内容和页表都会被保存。这一简化模型忽略了几个细节，首先CPU为了利益最大化，不会立即执行无事可做的进程，其次`Linux`支持不同的调度类别，如完全公平的调度和实时调度，所以当重要的进程可以运行时，可能会抢占当前进程。

![img](/img/in-post/post-process-management/201910231754.png)

*进程状态转换*

进程可能有以下几种状态：
- **运行**：该程序此刻正在执行
- **等待**：进程就绪等待执行
- **睡眠**：进程正在等待外部事件无法运行，调度器无法在切换时选择该进程
- **终止**：进程执行终止

系统将所有进程保存在一个进程表中，睡眠进程会特别标记出来分类到若干队列，在外部事件发生时唤醒；有一种特殊的僵尸状态，在`UNIX`操作系统下，进程终止必须首先由另一个进程或者用户杀死（通常是发送`SIGTERM`或`SIGKILL`），然后进程父进程在子进程终止后调用`wait4`系统调用，该系统调用使得内核可以释放为子进程保留的资源，当子进程终止而父进程未调用`wait4`时就会形成僵尸进程，僵尸进程耗费系统资源极少。

`Linux`进程管理结构还记录了另外两种进程状态选项：**用户态**和**内核态**，从用户态切换内核态有两种方式：
- 通过系统调用在受控情况下实现，这种访问经由明确的路径定义
- 通过中断触发，中断不可预测且与通常当前执行进程无关，例如网络数据包进入系统是通过中断

内核抢占调度模型的层次结构：
- 普通进程总是可能被抢占，当一个重要进程状态变为可运行时，调度器可以决定是否立即执行该进程
- 系统处于核心态并在处理系统调用时不可被抢占，但是中断可以中止系统调用
- 中断拥有最高优先级，可以暂停其他进程，因为中断触发后需要尽快处理

### 进程表示

`Linux`内核涉及进程的算法都围绕一个名为`task_struct`的数据结构建立，该结构定义在`include/sched.h`中，如下所示：

```cpp
struct task_struct {
  volatile long state; /* -1表示不可运行，0表示可运行，>0表示停止 */
  void *stack;
  atomic_t usage;
  
};
```
